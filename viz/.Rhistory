daily.pool.stats[!is.na(swap_fee_percent),
list(swap_fee_percent = sum(swap_volume_rune_usd *
swap_fee_percent)/sum(swap_volume_rune_usd, na.rm = T)),
by = pool_name_nice]
),
by = "pool_name_nice", all = TRUE)
RemoveNAs(pools.summary)
save(prices, pool.names, pools.summary, ten.day.swap.fee, file = "~/data_science/viz/thorchain/data.RData")
#save(, file = "/srv/shiny-server/thorswap/data.RData")
swaps_10_day[ pool_name_nice == 'AVA [BNB]' ]
swaps[ pool_name_nice == 'AVA [BNB]' ]
swaps[ pool_name_nice == 'AVA [BNB]' ] %>% group_by(day) %>% summarize(volume=sum(to_amount_usd)) %>% as.data.table()
swaps[ pool_name_nice == 'AVA [BNB]' ] %>% group_by(date) %>% summarize(volume=sum(to_amount_usd)) %>% as.data.table()
swaps_10_day <- swaps %>% group_by(pool_name_nice) %>% summarize(swaps_10_day=sum(to_amount_usd) * 10 / ifelse((n_distinct(date) > 10, 10, n_distinct(date))) %>% as.data.table()
swaps_10_day <- swaps %>% group_by(pool_name_nice) %>% summarize(swaps_10_day=sum(to_amount_usd), n_days=n_distinct(date)) %>% as.data.table()
swaps_10_day[, swaps_10_day := swaps_10_day * 10 / ifelse(n_days > 10, 10, n_days) ]
swaps[ pool_name_nice == 'AVA [BNB]' ] %>% group_by(date) %>% summarize(volume=sum(to_amount_usd)) %>% as.data.table()
pools.summary <- MergeDataFrames(list( daily.pool.stats[day == max_date,
list(pool_name_nice,
total_liquidity_usd = round(rune_liquidity*2*rune_price_usd))],
swaps[block_timestamp >= max(swaps$block_timestamp) - 60*60*24,
list(swaps_24h = round(sum(to_amount_usd))),
by = pool_name_nice],
swaps_10_day[, list(pool_name_nice, swaps_10_day)],
swaps[block_timestamp >= max(swaps$block_timestamp) - 60*60*24,
list(fees_24h = sum(liq_fee_asset)),
by = pool_name_nice],
daily.pool.stats[system_rewards_usd > 0] %>% group_by(pool_name_nice) %>% summarize(system_rewards_usd=mean(system_rewards_usd)) %>% as.data.table(),
daily.pool.stats[!is.na(swap_fee_percent),
list(swap_fee_percent = sum(swap_volume_rune_usd *
swap_fee_percent)/sum(swap_volume_rune_usd, na.rm = T)),
by = pool_name_nice]
),
by = "pool_name_nice", all = TRUE)
RemoveNAs(pools.summary)
save(prices, pool.names, pools.summary, ten.day.swap.fee, file = "~/data_science/viz/thorchain/data.RData")
#save(, file = "/srv/shiny-server/thorswap/data.RData")
swaps[ pool_name_nice == 'AVA [BNB]' ] %>% group_by(date) %>% summarize(volume=sum(to_amount_usd)) %>% as.data.table()
swaps_10_day <- swaps %>% group_by(pool_name_nice) %>% summarize(swaps_10_day=sum(to_amount_usd), n_days=n_distinct(date)) %>% as.data.table()
swaps_10_day
swaps_10_day[, swaps_10_day := swaps_10_day * 10 / ifelse(n_days > 10, 10, n_days) ]
swaps_10_day
swaps[ pool_name_nice == 'LTC [LTC]' ] %>% group_by(date) %>% summarize(volume=sum(to_amount_usd)) %>% as.data.table()
daily.pool.stats[pool_name_nice == 'LTC [LTC]', list(day, system_rewards_usd)]
updated_date <- max(swaps$block_timestamp)
updated_date
save(prices, pool.names, pools.summary, ten.day.swap.fee, updated.date, file = "~/data_science/viz/thorchain/data.RData")
updated.date <- max(swaps$block_timestamp)
save(prices, pool.names, pools.summary, ten.day.swap.fee, updated.date, file = "~/data_science/viz/thorchain/data.RData")
updated.date
paste0(updated.date)
head(#212B36)
)
head(balance)
source("~/data_science/util/util_functions.R")
earnings <- QuerySnowflake("select * from thorchain.daily_earnings")
upgrades <- QuerySnowflake("select * from thorchain.upgrades")
head(earnings)
head(upgrades)
unique(upgrades$burn_asset)
upgrades[, chain := strsplit(burn_asset, ".", FIXED=TRUE)[[1]][1] ]
upgrades[, chain := strsplit(burn_asset, ".", fixed=TRUE)[[1]][1] ]
unique(upgrades$chain)
upgrades[, chain := strsplit(burn_asset, ".", fixed=TRUE)[[1]][1], by = burn_asset ]
unique(upgrades$chain)
unique(upgrades[, list(chain, burn_asset)])
head(upgrades)
source("~/data_science/util/util_functions.R")
#################
#     TODOS     #
#################
##################################
#     RUNE Upgrades by Chain     #
##################################
# RUNE upgrades by chain { upgradesplot, upgradeusersplot }
upgrades <- QuerySnowflake("
SELECT block_timestamp::date AS day
, LEFT(burn_asset, CHARINDEX('.', burn_asset) - 1) AS chain
, COUNT(DISTINCT(to_address)) AS n_users
, SUM(rune_amount) AS rune_amount
, SUM(rune_amount_usd) AS rune_amount_usd
From flipside_dev_db.thorchain.upgrades
GROUP BY 1, 2
")
# block rewards { rewardsplot }
rewards <- QuerySnowflake("
SELECT *
From flipside_dev_db.thorchain.block_rewards
")
# daily tvl { tvlplot }
tvl <- QuerySnowflake("
SELECT *
From flipside_dev_db.thorchain.daily_tvl
")
# daily pool stats { lpvolumeplot, feesplot, stdfeesplot, liquiditycountplot, liquidityprovisionplot }
stats <- QuerySnowflake("
SELECT *
, CASE WHEN CHARINDEX('-', pool_name) > 0 THEN LEFT(pool_name, CHARINDEX('-', pool_name) - 1) ELSE pool_name END AS chain_asset
, (asset_liquidity * asset_price_usd) + (rune_liquidity * rune_price_usd) AS pool_depth_usd
, (asset_liquidity * asset_price) + (rune_liquidity) AS pool_depth_rune
From flipside_dev_db.thorchain.daily_pool_stats
")
stats[ is.na(stats) ] <- 0
stats[ withdraw_rune_liquidity_usd > 0, withdraw_rune_liquidity_usd := withdraw_rune_liquidity_usd * -1 ]
stats[ withdraw_asset_liquidity_usd > 0, withdraw_asset_liquidity_usd := withdraw_asset_liquidity_usd * -1 ]
stats[, withdraw_liquditiy_usd := withdraw_rune_liquidity_usd + withdraw_rune_liquidity_usd ]
stats[, add_liquditiy_usd := add_rune_liquidity_usd + add_asset_liquidity_usd ]
stats[, net_liquidity_usd := add_liquditiy_usd + withdraw_liquditiy_usd ]
stats[ withdraw_count > 0, withdraw_count := withdraw_count * -1 ]
stats[, net_liquidity_count := add_liquidity_count + withdraw_count ]
stats[, std_fees := total_swap_fees_usd * 1000 / swap_volume_rune_usd ]
head(stats)
# asset prices by day { candlestickpriceplot }
prices <- QuerySnowflake("
WITH base AS (
SELECT block_timestamp
, date(block_timestamp) AS day
, CASE WHEN CHARINDEX('-', pool_name) > 0 THEN LEFT(pool_name, CHARINDEX('-', pool_name) - 1) ELSE pool_name END AS pool_name
, ROW_NUMBER() OVER (PARTITION BY day, pool_name ORDER BY block_timestamp ASC) AS rn_asc
, ROW_NUMBER() OVER (PARTITION BY day, pool_name ORDER BY block_timestamp DESC) AS rn_desc
, asset_usd
From flipside_dev_db.thorchain.prices
), mxmn AS (
SELECT pool_name
, day
, MAX(asset_usd) AS mx_price
, MIN(asset_usd) AS mn_price
FROM base
GROUP BY 1, 2
), open AS (
SELECT pool_name
, day
, asset_usd AS open_price
FROM base
WHERE rn_asc = 1
), close AS (
SELECT pool_name
, day
, asset_usd AS close_price
FROM base
WHERE rn_desc = 1
)
SELECT m.*
, o.open_price
, c.close_price
FROM mxmn m
JOIN open o ON o.day = m.day
AND o.pool_name = m.pool_name
JOIN close c ON c.day = m.day
AND c.pool_name = m.pool_name
")
# { swapvolumeplot, swapusersplot, swapcountplot }
# https://viewblock.io/thorchain/tx/E92C5ED62600261D034B3EBC9F1848DF9AC2F5A4A21B49314A0A7E344C746457
# swaps are a little funky. in multiple rows the from_addr is the same and the real to_addr is in the memo
# , COUNT(DISTINCT CASE WHEN to_asset like '%RUNE%' THEN from_addr ELSE to_addr END) AS n_users
# , SUM(CASE WHEN to_asset like '%RUNE%' THEN to_e8 ELSE from_e8 END) / POW(10, 8) AS amount
# swaps table is missing rows
# TODO: a BTC -> RUNE -> BCH is considered 2 swaps
swaps <- QuerySnowflake("
SELECT date(block_timestamp) AS day
, CASE WHEN CHARINDEX('-', pool_name) > 0 THEN LEFT(pool_name, CHARINDEX('-', pool_name) - 1) ELSE pool_name END AS chain_asset
, COUNT(DISTINCT from_address) AS n_users
, COUNT(1) AS n_swaps
, SUM(to_amount_usd) AS amount_usd
From flipside_dev_db.thorchain.swaps
GROUP BY 1, 2
")
#############################
#     Top Tokens Tables     #
#############################
# get swap data for the last 24h since the data was refreshed { metrics_table }
swaps_24h <- QuerySnowflake("
WITH end AS (
SELECT MAX(block_timestamp) AS end
From flipside_dev_db.thorchain.swaps
)
SELECT CASE WHEN CHARINDEX('-', pool_name) > 0 THEN LEFT(pool_name, CHARINDEX('-', pool_name) - 1) ELSE pool_name END AS pool_name
, SUM( from_amount_usd + to_amount_usd ) / 2.0 AS swap_volume_usd
, COUNT(1) AS n_swaps
From flipside_dev_db.thorchain.swaps s
JOIN end e ON s.block_timestamp > DATEADD( 'minutes', -24 * 60, e.end )
GROUP BY 1
ORDER BY 2 DESC
")
# get pool balances for the most recent block id { metrics_table }
pool_balances <- QuerySnowflake("
WITH end AS (
SELECT MAX(block_id) AS block_id
From flipside_dev_db.thorchain.pool_block_balances
)
SELECT CASE WHEN CHARINDEX('-', pool_name) > 0 THEN LEFT(pool_name, CHARINDEX('-', pool_name) - 1) ELSE pool_name END AS pool_name
, rune_amount
, rune_amount_usd
, asset_amount
, asset_amount_usd
, rune_amount_usd + asset_amount_usd AS liquidity_usd
, asset_amount_usd / asset_amount AS price
From flipside_dev_db.thorchain.pool_block_balances s
JOIN end e ON e.block_id = s.block_id
ORDER BY 6 DESC
")
# merge together to get the tokens table
tokens_table <- merge(pool_balances, swaps_24h, all.x=TRUE)
tokens_table <- tokens_table[order(-liquidity_usd)]
tokens_table[is.na(tokens_table)] <- 0
tokens_table <- tokens_table[, list(pool_name, liquidity_usd, price, swap_volume_usd, n_swaps)]
##############################
#     CEX On / Off Ramps     #
##############################
# get movement in and out of crypto.com { cexrampplot }
cex_ramps <- QuerySnowflake("
SELECT DATE(block_timestamp) AS day
, SUM(CASE WHEN from_addr = 'thor1ty6h2ll07fqfzumphp6kq3hm4ps28xlm2l6kd6' THEN amount_e8 ELSE 0 END) / POW(10, 8) AS on_amount
, SUM(CASE WHEN to_addr = 'thor1ty6h2ll07fqfzumphp6kq3hm4ps28xlm2l6kd6' THEN -amount_e8 ELSE 0 END) / POW(10, 8) AS off_amount
, SUM(CASE WHEN from_addr = 'thor1ty6h2ll07fqfzumphp6kq3hm4ps28xlm2l6kd6' THEN amount_e8 ELSE -amount_e8 END) / POW(10, 8) AS net_amount
From flipside_dev_db.thorchain_midgard_public.transfer_events
WHERE (
from_addr = 'thor1ty6h2ll07fqfzumphp6kq3hm4ps28xlm2l6kd6'
OR to_addr = 'thor1ty6h2ll07fqfzumphp6kq3hm4ps28xlm2l6kd6'
)
GROUP BY 1
")
#####################################################
#     Calculate Unique LP-ers in Pool Over Time     #
#####################################################
# get detail for liquidity_actions { lpusersplot }
liquidity_actions <- QuerySnowflake("
SELECT tx_id
, CASE WHEN CHARINDEX('-', pool_name) > 0 THEN LEFT(pool_name, CHARINDEX('-', pool_name) - 1) ELSE pool_name END AS pool_name
, block_timestamp::date AS day
, from_address
, asset_address
, stake_units
, lp_action
From flipside_dev_db.thorchain.liquidity_actions
")
# map addresses from different chains to match input and output
id_map <- unique( liquidity_actions[ !is.na(from_address) & !is.na(asset_address), list(pool_name, from_address, asset_address) ] )
rev <- id_map[, list(pool_name, asset_address, from_address)]
colnames(rev) <- colnames(id_map)
id_map <- rbind(id_map, rev)
#liquidity_actions[ pool_name=='BNB.BTCB-1DE' & from_address=='thor10dsupalv3grufhz5tr9hsjj04cm55x0lmk5fus'][order(asset_address), list(pool_name, asset_address)]
n <- id_map %>% group_by(pool_name, from_address) %>% summarize(n=n()) %>% as.data.table()
id_map <- merge(id_map, n[ n==1, list(pool_name, from_address)])
tmp <- merge( liquidity_actions, id_map, by=c('pool_name','from_address'), all.x=T )
tmp[ !is.na(asset_address.x) & asset_address.x != asset_address.y ]
tmp[ , asset_address := ifelse(is.na(asset_address.x), asset_address.y, asset_address.x) ]
tmp <- merge( tmp, id_map, by=c('pool_name','asset_address'), all.x=T )
tmp[ , from_address := ifelse(is.na(from_address.x), from_address.y, from_address.x) ]
tmp[is.na(from_address.x)]
tmp[, id := ifelse(
is.na(from_address)
, asset_address
, ifelse(
is.na(asset_address)
, from_address
, ifelse(
from_address > asset_address
, paste0(from_address, ".", asset_address)
, paste0(asset_address, ".", from_address)
)
)
) ]
a <- unique(tmp[lp_action=='add_liquidity']$id)
r <- unique(tmp[lp_action=='remove_liquidity']$id)
length(tmp[lp_action=='remove_liquidity' & !id %in% a]$stake_units)
head(tmp[lp_action=='remove_liquidity' & !id %in% a])
head(tmp[lp_action=='remove_liquidity' & !id %in% a]$stake_units)
tmp[ from_address == 'qpwzc7yrfmfuzrf4frm2y58yhpqx0whh0vtzwvfe0q' | asset_address == 'qpwzc7yrfmfuzrf4frm2y58yhpqx0whh0vtzwvfe0q' ]
unqique_stake_units <- tmp %>%
group_by(pool_name, stake_units) %>%
summarize(n=n()) %>%
as.data.table()
unqique_stake_units <- unqique_stake_units[n==2, list(pool_name, stake_units)]
unqique_stake_units[, use_stake_units := 1]
tmp <- merge(tmp, unqique_stake_units, all.x=T, by=c( 'pool_name', 'stake_units' ))
tmp[ use_stake_units == 1, id := paste0( pool_name, ".", stake_units) ]
tmp[, add_stake_units := ifelse(lp_action == 'add_liquidity', stake_units, 0) ]
tmp[, rem_stake_units := ifelse(lp_action == 'remove_liquidity', stake_units, 0) ]
tmp <- tmp %>%
group_by( pool_name, day, id ) %>%
summarize( add_stake_units=sum(add_stake_units), rem_stake_units=sum(rem_stake_units) ) %>%
as.data.table()
mn <- min(tmp$day)
mx <- max(tmp$day)
dates <- c()
while (mn <= mx) {
dates <- c( dates, mn )
mn = mn + 1
}
calendar <- data.table(day=as.Date(dates))
ids <- unique(tmp$id)
pool_name <- unique(tmp$pool_name)
base <- CJ(calendar$day, pool_name, ids)
colnames(base) <- c( 'day', 'pool_name', 'id' )
base <- merge(base, tmp, all.x=T, on=c('day','pool_name','id'))
base[is.na(base)] <- 0
base <- base[order(day, id)]
base[, net_stake_units := add_stake_units - rem_stake_units ]
base <- base[order(day, id)]
base[, cum_add_stake_units := cumsum(add_stake_units), by=list(pool_name, id)]
base[, cum_rem_stake_units := cumsum(rem_stake_units), by=list(pool_name, id)]
base[, cum_net_stake_units := cumsum(net_stake_units), by=list(pool_name, id)]
base[ cum_add_stake_units == add_stake_units & cum_add_stake_units > 0, user_add_lp := 1]
base[ cum_net_stake_units == 0 & rem_stake_units > 0, user_rem_lp := 1]
base[, prv_cum_rem_stake_units := shift(cum_rem_stake_units, 1), by=list(pool_name, id)]
# head(base[cum_rem_stake_units != 0])
# head(base[cum_rem_stake_units != 0 & pool_name == 'ETH.ETH' & id == '0x07dadde841ca7aca8b313ef7a1b1998ab567cfc5'])
# head(base[pool_name == 'ETH.ETH' & id == '0x07dadde841ca7aca8b313ef7a1b1998ab567cfc5'][order(day)])
base[ prv_cum_rem_stake_units == 0 & rem_stake_units > 0 & cum_add_stake_units == 0, user_rem_lp := 1]
base[ prv_cum_rem_stake_units == 0 & rem_stake_units > 0 & cum_add_stake_units == 0]
base[is.na(base)] <- 0
lp_users <- base %>%
group_by( pool_name, day ) %>%
summarize(
user_add_lp = sum(user_add_lp)
, user_rem_lp = sum(user_rem_lp)
) %>% as.data.table()
lp_users <- lp_users[order(pool_name, day)]
lp_users[, cum_user_add_lp := cumsum(user_add_lp), by=list(pool_name) ]
lp_users[, cum_user_rem_lp := cumsum(user_rem_lp), by=list(pool_name) ]
lp_users[, cum_user_net_lp := cum_user_add_lp - cum_user_rem_lp ]
####################
#     Pool APY     #
####################
# calculate the APY of each pool for each week { apyplot }
apy <- QuerySnowflake("
WITH base AS (
SELECT WEEKOFYEAR(day) AS week
, CASE WHEN CHARINDEX('-', pool_name) > 0 THEN LEFT(pool_name, CHARINDEX('-', pool_name) - 1) ELSE pool_name END AS pool_name
, MIN(day) AS day
, COUNT(DISTINCT day) AS n_days
, AVG((asset_liquidity * asset_price_usd) + (rune_liquidity * rune_price_usd)) AS liquidity_usd
, SUM(COALESCE(system_rewards_usd, 0)) AS system_rewards_usd
, SUM(COALESCE(total_swap_fees_usd, 0)) AS total_swap_fees_usd
From flipside_dev_db.thorchain.daily_pool_stats
GROUP BY 1, 2
ORDER BY 1 DESC, 2
)
SELECT day
, pool_name
, (total_swap_fees_usd + system_rewards_usd) * 365 / (n_days * liquidity_usd) AS apy
FROM base
ORDER BY 1 DESC, 2
")
#############################################################
#     Calculate the Balance of the Various Wallet Types     #
#############################################################
# { supplyplot }
wallet_balance <- QuerySnowflake("
WITH base AS (
SELECT DATE(block_timestamp) AS day
, CASE
WHEN from_addr = 'thor1dheycdevq39qlkxs2a6wuuzyn4aqxhve4qxtxt' THEN 'Reserve'
WHEN from_addr = 'thor17gw75axcnr8747pkanye45pnrwk7p9c3cqncsv' THEN 'Bond'
WHEN from_addr = 'thor1g98cy3n9mmjrpn0sxmn63lztelera37n8n67c0' THEN 'Pool'
WHEN from_addr = 'thor1ty6h2ll07fqfzumphp6kq3hm4ps28xlm2l6kd6' THEN 'crypto.com'
ELSE 'Wallet' END AS wallet_type
, SUM(-amount_e8) / POW(10, 8) AS rune_amount
From flipside_dev_db.thorchain_midgard_public.transfer_events
WHERE from_addr <> 'thor1v8ppstuf6e3x0r4glqc68d5jqcs2tf38cg2q6y'
GROUP BY 1, 2
UNION ALL
SELECT DATE(block_timestamp) AS day
, CASE
WHEN to_addr = 'thor1dheycdevq39qlkxs2a6wuuzyn4aqxhve4qxtxt' THEN 'Reserve'
WHEN to_addr = 'thor17gw75axcnr8747pkanye45pnrwk7p9c3cqncsv' THEN 'Bond'
WHEN to_addr = 'thor1g98cy3n9mmjrpn0sxmn63lztelera37n8n67c0' THEN 'Pool'
WHEN to_addr = 'thor1ty6h2ll07fqfzumphp6kq3hm4ps28xlm2l6kd6' THEN 'crypto.com'
ELSE 'Wallet' END AS wallet_type
, SUM(amount_e8) / POW(10, 8) AS rune_amount
From flipside_dev_db.thorchain_midgard_public.transfer_events
WHERE to_addr <> 'thor1v8ppstuf6e3x0r4glqc68d5jqcs2tf38cg2q6y'
GROUP BY 1, 2
)
SELECT day, wallet_type, SUM(rune_amount) AS rune_amount
FROM base
GROUP BY 1, 2
")
mn <- min(wallet_balance$day)
mx <- max(wallet_balance$day)
dates <- c()
while (mn <= mx) {
dates <- c( dates, mn )
mn = mn + 1
}
calendar <- data.table(day=as.Date(dates))
wallet_type <- data.table(wallet_type=unique(wallet_balance$wallet_type))
rune_supply <- CJ(calendar$day, wallet_type$wallet_type)
colnames(rune_supply) = c('day','wallet_type')
rune_supply <- merge( rune_supply, wallet_balance, all.x=TRUE )
rune_supply[is.na(rune_supply)] <- 0
rune_supply <- rune_supply[order(wallet_type, day)]
rune_supply[, rune_amount := cumsum(rune_amount), by=list(wallet_type)]
#rune_supply <- rbind(bond_amount, pool_amount) is this redundant/unnecessary?
#############################################
#     Set the time the data was updated     #
#############################################
updated.date <- max(upgrades$day)
valid <- unique(swaps[ day >= max(swaps$day) - 3 ]$chain_asset)
prices <- prices[ pool_name %in% eval(valid) ]
unique(prices$pool_name)
############################
#     Save .RData file     #
############################
save(
tvl,
apy,
stats,
swaps,
prices,
rewards,
lp_users,
upgrades,
cex_ramps,
rune_supply,
tokens_table,
updated.date,
file = "/srv/shiny-server/thorchain-console/data.RData"
)
# save(prices, pool.names, pools.summary, ten.day.swap.fee, updated.date, file = "/srv/shiny-server/thorchain-console/data.RData")
save(prices, pool.names, pools.summary, ten.day.swap.fee, updated.date, file = "/srv/shiny-server/thorchain-console/data.RData")
save(prices, pool.names, pools.summary, ten.day.swap.fee, updated.date, file = "~/data_science/viz/thorchain-console/data.RData")
############################
save(
tvl,
apy,
stats,
swaps,
prices,
rewards,
lp_users,
upgrades,
cex_ramps,
rune_supply,
tokens_table,
updated.date,
# file = "/srv/shiny-server/thorchain-console/data.RData"
file = "~/data_science/viz/thorchain-console/data.RData"
)
setwd("~/git/nft-deal-score/viz")
# TODO: look at stability over time
# setwd("~/git/nft-deal-score/viz")
source("~/data_science/util/util_functions.R")
library(DT)
library(data.table)
library(shiny)
library(ggplot2)
library(scales)
library(tools)
library(shinyWidgets)
library(plotly)
library(shinyBS)
library(tippy)
library(bslib)
library(shinyjs)
require(reshape2)
require(dplyr)
require(RPostgreSQL)
library(RJSONIO)
library(htmlwidgets)
library(stringr)
library(showtext)
library(fmsb)
library(reactable)
font_add_google(name = "Roboto Condensed", family = "roboto-condensed")
font_add_google(name = "Roboto Mono", family = "roboto-mono")
showtext_auto()
# library(elementalist)
BG_COLOR = '#282923'
plotly.style <- list(
fig_bgcolor = "rgb(255, 255, 255)",
plot_bgcolor = "rgba(0, 0, 0, 0)",
paper_bgcolor = "rgba(0, 0, 0, 0)",
font = list(
color = '#919EAB', family = "Roboto Mono")
)
getTokenAddress <- function(x) {
token_address <- tryCatch(
{
strsplit( as.character(x), "\\(|\\)")[[1]][2]
},
error = function(e){
},
warning = function(w){
},
finally = {
}
)
return(token_address)
}
getTokenSymbol <- function(x) {
token_address <- tryCatch(
{
strsplit( as.character(x), "\\(|\\)")[[1]][1]
},
error = function(e){
},
warning = function(w){
},
finally = {
}
)
return(token_address)
}
printNumber <- function(x) {
return(prettyNum(x, format='d', big.mark=',', digits=5))
}
printPercent <- function(x) {
return(label_percent()(x))
}
runApp()
