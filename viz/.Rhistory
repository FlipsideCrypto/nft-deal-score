g <- transaction_detail[ (tx_type == 'Swap') & (!is.na(to_label)) ] %>%
group_by( to_label, to_label_type, to_label_subtype ) %>%
summarize(n=n()) %>%
as.data.table()
g <- g[order(-n)]
head(g)
nrow(transaction_detail)
head(transaction_detail[ (tx_type == 'Swap') & (!is.na(to_label)) ])
head(transaction_detail[ (tx_type == 'Swap')])
head(transaction_detail[ (tx_type == 'Swap') && (!is.na(to_label)) ])
head(transaction_detail[ !is.na(to_label) ])
head(transaction_detail[ tx_type == 'Swap' ])
head(transaction_detail[ (tx_type == 'Swap') & (is.na(to_label)) ])
head(transaction_detail[ (tx_type == 'Swap') & (!is.na(to_label)) ])
head(transaction_detail[ (tx_type == 'Swap') & (!is.na(from_label)) ])
transaction_detail[ tx_id=='0xcf9d686240cfb8fdfc7d22f6b9ce6f44acb3c9aeb83d6e22904a410cb9134970' ]
ptm <- proc.time()
query <- paste0(valid,", s AS (
SELECT DISTINCT tx_id
FROM ethereum.events_emitted
WHERE (
event_name ilike '%swap%'
AND tx_to_label_type = 'dex'
)
OR (
event_name = 'Swap' AND (
tx_to_label = 'furucombo'
OR tx_to_label = 'dxdao'
OR contract_name like '% UNI-V2 LP'
OR contract_name like '% UNI-V3 LP'
OR contract_name like '% SLP'
OR contract_name ilike 'uniswap%'
OR contract_name ilike 'sushiswap%'
)
)
OR (
event_name IN ('Deposit','Withdrawal')
AND (
tx_to_label = 'tokenlon'
)
)
OR (
event_name = 'FeiExchange'
AND contract_address = '0xa08a721dfb595753fff335636674d76c455b275c'
)
), l AS (
SELECT DISTINCT tx_id
FROM ethereum.events_emitted
WHERE event_name IN (
'Deposit'
, 'Withdrawal'
, 'IncreaseLiquidity'
, 'DecreaseLiquidity'
, 'AddLiquidity'
, 'RemoveLiquidityOne'
, 'RemoveLiquidity'
, 'LiquidityRemoved'
)
), cnt AS (
SELECT tx_id, COUNT(1) AS n_events
FROM ethereum.udm_events
GROUP BY 1
)
SELECT
u.tx_id
, CASE
WHEN from_label IS NOT NULL AND to_label IS NOT NULL THEN 'Intra-Protocol Transfer'
WHEN origin_function_name = 'redeem' THEN 'Airdrop'
WHEN s.tx_id IS NOT NULL
OR origin_function_name IN ( 'swap','swapETHForExactTokens','swapExactETHForTokens','swapExactTokensForETH','swapExactTokensForTokens','swapTokensForExactTokens' )
THEN 'Swap'
WHEN l.tx_id IS NOT NULL OR origin_function_name IN ('addLiquidity','removeLiquidity','removeLiquidityWithPermit','removeLiquidity','withdrawAll','withdraw','deposit') THEN 'LP'
WHEN origin_function_name = 'purchase' THEN 'Purchase'
WHEN origin_function_name IN ('borrow','repayBorrow') THEN 'Borrowing'
WHEN COALESCE( to_label_type, from_label_type ) = 'cex' THEN 'CEX'
WHEN l.tx_id IS NULL AND COALESCE( to_label_type, from_label_type ) = 'dex' THEN 'Swap'
WHEN u.origin_function_signature = '0xb7e93121' THEN 'Burn'
WHEN c.n_events = 1 AND origin_function_name = 'transfer' THEN 'Direct Transfer'
ELSE 'Other'
END AS tx_type
, DATE_TRUNC(day, block_timestamp) AS date
, u.contract_address
, to_address
, to_label
, to_label_type
, to_label_subtype
, from_address
, from_label
, from_label_type
, from_label_subtype
, amount
, amount_usd
FROM ethereum.udm_events u
JOIN valid v ON v.contract_address = u.contract_address
LEFT JOIN cnt c ON c.tx_id = u.tx_id
LEFT JOIN s ON s.tx_id = u.tx_id
LEFT JOIN l ON l.tx_id = u.tx_id
WHERE amount > 0
AND block_timestamp >= CURRENT_DATE - 300
")
transaction_detail <- QuerySnowflake({query})
print(proc.time() - ptm)
g <- transaction_detail[ (tx_type == 'Swap') && (!is.na(to_label)) ] %>%
group_by( to_label, to_label_type, to_label_subtype ) %>%
summarize(n=n()) %>%
as.data.table()
g <- g[order(-n)]
head(g)
g <- transaction_detail[ (tx_type == 'Swap') && (!is.na(from_label)) ] %>%
group_by( to_label, to_label_type, to_label_subtype ) %>%
summarize(n=n()) %>%
as.data.table()
g <- g[order(-n)]
head(g)
head(transaction_detail[ (tx_type == 'Swap') & (!is.na(to_label)) ])
g <- transaction_detail[ (tx_type == 'Swap') & (!is.na(from_label)) ] %>%
group_by( to_label, to_label_type, to_label_subtype ) %>%
summarize(n=n()) %>%
as.data.table()
g <- g[order(-n)]
head(g)
g <- transaction_detail[ (tx_type == 'Swap') & (!is.na(to_label)) ] %>%
group_by( to_label, to_label_type, to_label_subtype ) %>%
summarize(n=n()) %>%
as.data.table()
g <- g[order(-n)]
head(g)
head(transaction_detail[ (tx_type == 'Swap') & (!is.na(to_label)) & (to_label_subtype == 'general_contract') & (to_label=='uniswap') ])
head(transaction_detail[ (tx_type == 'Swap') & (!is.na(to_label)) & (to_label_subtype == 'genesis') & (to_label=='genesis') ])
head(g, 20)
write.csv(g, '~/Downloads/tmp.csv', row.names=F)
head(transaction_detail[ (tx_type == 'Swap') & (!is.na(to_label)) & (to_label_subtype == 'nft') & (to_label=='ens') ])
head(transaction_detail[ (tx_type == 'Swap') & (!is.na(to_label)) & (to_label_type == 'nft') & (to_label=='ens') ])
head(transaction_detail[ tx_id == '0x25a826403177a34282d0f2bc8496197bf25bf51995453ebdcb13adeec9aaceef' ])
substr("asdfs", 3)
substr("asdfs", 3, 1)
substr("asdfs", 3, 4)
substr("Wrappedasdfs", 1, 7)
library('ggplot2')
df <- data.frame(dose=c("D0.5", "D1", "D2"),
len=c(4.2, 10, 29.5))
head(df)
p<-ggplot(data=df, aes(x=dose, y=len)) +
geom_bar(stat="identity")
p
source("~/data_science/util/util_functions.R")
#getdate() - interval '26 days'
# TODO: thorswap github how do they calc apy, system_rewards_usd how many days?
# bottom - how is it calculated?
daily.pool.stats <- QuerySnowflake("SELECT * FROM thorchain.daily_pool_stats
WHERE day >= getdate() - interval '10 days'")
ReplaceValues(daily.pool.stats)
swaps <- QuerySnowflake("SELECT * FROM thorchain.swaps
WHERE block_timestamp >= getdate() - interval '10 days'")
prices <- QuerySnowflake("WITH valid AS (
SELECT DISTINCT pool_name
FROM thorchain.swaps
)
SELECT
p.pool_name,
date_trunc('hour', block_timestamp) AS price_hour,
avg(rune_usd) AS rune_price,
avg(asset_usd) AS asset_price
FROM thorchain.prices p
JOIN valid v ON v.pool_name = p.pool_name
WHERE block_timestamp >= getdate() - interval '180 days'
GROUP BY p.pool_name, price_hour")
pool.names <- data.table(pool_name = unique(prices$pool_name))
pool.names[, pool_blockchain := strsplit(pool_name, ".", fixed = TRUE)[[1]][1], by = pool_name]
pool.names[, pool_token := strsplit(strsplit(pool_name, ".", fixed = TRUE)[[1]][2], "-", fixed = TRUE)[[1]][1], by = pool_name]
pool.names[, pool_name_nice := paste0(pool_token, " [", pool_blockchain, "]")]
# add these nice names to the other tables:
daily.pool.stats <- merge(pool.names, daily.pool.stats, by = "pool_name")
swaps <- merge(pool.names, swaps, by = "pool_name")
prices <- merge(pool.names, prices, by = "pool_name")
prices[, rune_price := round(rune_price, 3)]
prices[, asset_price := round(asset_price, 3)]
daily.pool.stats[, max_date := max(day), by = pool_name]
prices[, max_date := max(price_hour), by = pool_name]
# average swap fee:
daily.pool.stats[, swap_fee_percent := (total_swap_fees_usd) / (swap_volume_rune_usd) * 100]
daily.pool.stats[ swap_volume_rune_usd > 0 , list(swap_fee_percent, total_swap_fees_usd, swap_volume_rune_usd, system_rewards_usd)]
daily.pool.stats[day == max_date, list(pool_name_nice, system_rewards_usd)]
ten.day.swap.fee
source("~/data_science/util/util_functions.R")
#getdate() - interval '26 days'
# TODO: thorswap github how do they calc apy, system_rewards_usd how many days?
# bottom - how is it calculated?
daily.pool.stats <- QuerySnowflake("SELECT * FROM thorchain.daily_pool_stats
WHERE day >= getdate() - interval '10 days'")
ReplaceValues(daily.pool.stats)
swaps <- QuerySnowflake("SELECT * FROM thorchain.swaps
WHERE block_timestamp >= getdate() - interval '10 days'")
prices <- QuerySnowflake("WITH valid AS (
SELECT DISTINCT pool_name
FROM thorchain.swaps
)
SELECT
p.pool_name,
date_trunc('hour', block_timestamp) AS price_hour,
avg(rune_usd) AS rune_price,
avg(asset_usd) AS asset_price
FROM thorchain.prices p
JOIN valid v ON v.pool_name = p.pool_name
WHERE block_timestamp >= getdate() - interval '180 days'
GROUP BY p.pool_name, price_hour")
pool.names <- data.table(pool_name = unique(prices$pool_name))
pool.names[, pool_blockchain := strsplit(pool_name, ".", fixed = TRUE)[[1]][1], by = pool_name]
pool.names[, pool_token := strsplit(strsplit(pool_name, ".", fixed = TRUE)[[1]][2], "-", fixed = TRUE)[[1]][1], by = pool_name]
pool.names[, pool_name_nice := paste0(pool_token, " [", pool_blockchain, "]")]
# add these nice names to the other tables:
daily.pool.stats <- merge(pool.names, daily.pool.stats, by = "pool_name")
swaps <- merge(pool.names, swaps, by = "pool_name")
prices <- merge(pool.names, prices, by = "pool_name")
prices[, rune_price := round(rune_price, 3)]
prices[, asset_price := round(asset_price, 3)]
daily.pool.stats[, max_date := max(day), by = pool_name]
prices[, max_date := max(price_hour), by = pool_name]
# average swap fee:
daily.pool.stats[, swap_fee_percent := (total_swap_fees_usd) / (swap_volume_rune_usd) * 100]
daily.pool.stats[ swap_volume_rune_usd > 0 , list(swap_fee_percent, total_swap_fees_usd, swap_volume_rune_usd, system_rewards_usd)]
sum(daily.pool.stats[ swap_volume_rune_usd > 0 ]$total_swap_fees_usd) / sum(daily.pool.stats[ swap_volume_rune_usd > 0 ]$swap_volume_rune_usd)
ten.day.swap.fee <- as.numeric(daily.pool.stats[!is.na(swap_fee_percent),
list(swap_fee_percent = list(sum(swap_volume_rune_usd *
swap_fee_percent)/sum(swap_volume_rune_usd, na.rm = T)))]$swap_fee_percent)
pools.summary <- MergeDataFrames(list( daily.pool.stats[day == max_date,
list(pool_name_nice,
total_liquidity_usd = round(rune_liquidity*2*rune_price_usd))],
swaps[block_timestamp >= max(swaps$block_timestamp) - 60*60*24,
list(swaps_24h = round(sum(to_amount_usd))),
by = pool_name_nice],
swaps[, list(swaps_10_day = round(sum(to_amount_usd))),
by = pool_name_nice],
swaps[block_timestamp >= max(swaps$block_timestamp) - 60*60*24,
list(fees_24h = sum(liq_fee_asset)),
by = pool_name_nice],
daily.pool.stats %>% groupby(pool_name_nice) %>% summarize(system_rewards_usd=mean(system_rewards_usd)) %>% as.data.table(),
daily.pool.stats[!is.na(swap_fee_percent),
list(swap_fee_percent = sum(swap_volume_rune_usd *
swap_fee_percent)/sum(swap_volume_rune_usd, na.rm = T)),
by = pool_name_nice]
),
by = "pool_name_nice", all = TRUE)
RemoveNAs(pools.summary)
save(prices, pool.names, pools.summary, ten.day.swap.fee, file = "~/data_science/viz/thorchain/data.RData")
#save(, file = "/srv/shiny-server/thorswap/data.RData")
pools.summary <- MergeDataFrames(list( daily.pool.stats[day == max_date,
list(pool_name_nice,
total_liquidity_usd = round(rune_liquidity*2*rune_price_usd))],
swaps[block_timestamp >= max(swaps$block_timestamp) - 60*60*24,
list(swaps_24h = round(sum(to_amount_usd))),
by = pool_name_nice],
swaps[, list(swaps_10_day = round(sum(to_amount_usd))),
by = pool_name_nice],
swaps[block_timestamp >= max(swaps$block_timestamp) - 60*60*24,
list(fees_24h = sum(liq_fee_asset)),
by = pool_name_nice],
daily.pool.stats %>% group_by(pool_name_nice) %>% summarize(system_rewards_usd=mean(system_rewards_usd)) %>% as.data.table(),
daily.pool.stats[!is.na(swap_fee_percent),
list(swap_fee_percent = sum(swap_volume_rune_usd *
swap_fee_percent)/sum(swap_volume_rune_usd, na.rm = T)),
by = pool_name_nice]
),
by = "pool_name_nice", all = TRUE)
RemoveNAs(pools.summary)
save(prices, pool.names, pools.summary, ten.day.swap.fee, file = "~/data_science/viz/thorchain/data.RData")
ten.day.swap.fee
daily.pool.stats
daily.pool.stats[!is.na(swap_fee_percent)]
head(daily.pool.stats[!is.na(swap_fee_percent)])
head(daily.pool.stats[!is.na(swap_fee_percent)],1)
head(daily.pool.stats[!is.na(swap_fee_percent)],2)
daily.pool.stats[!is.na(swap_fee_percent),
list(swap_fee_percent = list(sum(swap_volume_rune_usd *
swap_fee_percent)/sum(swap_volume_rune_usd, na.rm = T)))]$swap_fee_percent
sum(daily.pool.stats[ swap_volume_rune_usd > 0 ]$total_swap_fees_usd) / sum(daily.pool.stats[ swap_volume_rune_usd > 0 ]$swap_volume_rune_usd)
n_days <- swaps %>% group_by(pool_name_nice) %>% summarize(n_days=n_distinct(date))
swaps <- QuerySnowflake("SELECT *, block_timestamp::date AS date FROM thorchain.swaps
WHERE block_timestamp >= getdate() - interval '10 days'")
head(swaps)
n_days <- swaps %>% group_by(pool_name_nice) %>% summarize(n_days=n_distinct(date))
swaps <- merge(pool.names, swaps, by = "pool_name")
n_days <- swaps %>% group_by(pool_name_nice) %>% summarize(n_days=n_distinct(date))
n_days
n_days <- swaps %>% group_by(pool_name_nice) %>% summarize(n_days=n_distinct(date)) %>% as.data.table()
swaps[, list(swaps_10_day = round(sum(to_amount_usd))),
by = pool_name_nice],
swaps[, list(swaps_10_day = round(sum(to_amount_usd))),
by = pool_name_nice]
n_days <- swaps %>% group_by(pool_name_nice) %>% summarize(n_days=n_distinct(date)) %>% as.data.table()
swaps_10_day <- swaps %>% group_by(pool_name_nice) %>% summarize(swaps_10_day=sum(to_amount_usd))
swaps_10_day <- merge( swaps_10_day, n_days )
swaps_10_day[, swaps_10_day := round(swaps_10_day / n_days)]
pools.summary <- MergeDataFrames(list( daily.pool.stats[day == max_date,
list(pool_name_nice,
total_liquidity_usd = round(rune_liquidity*2*rune_price_usd))],
swaps[block_timestamp >= max(swaps$block_timestamp) - 60*60*24,
list(swaps_24h = round(sum(to_amount_usd))),
by = pool_name_nice],
swaps_10_day,
swaps[block_timestamp >= max(swaps$block_timestamp) - 60*60*24,
list(fees_24h = sum(liq_fee_asset)),
by = pool_name_nice],
daily.pool.stats %>% group_by(pool_name_nice) %>% summarize(system_rewards_usd=mean(system_rewards_usd)) %>% as.data.table(),
daily.pool.stats[!is.na(swap_fee_percent),
list(swap_fee_percent = sum(swap_volume_rune_usd *
swap_fee_percent)/sum(swap_volume_rune_usd, na.rm = T)),
by = pool_name_nice]
),
by = "pool_name_nice", all = TRUE)
RemoveNAs(pools.summary)
save(prices, pool.names, pools.summary, ten.day.swap.fee, file = "~/data_science/viz/thorchain/data.RData")
#save(, file = "/srv/shiny-server/thorswap/data.RData")
n_days <- swaps %>% group_by(pool_name_nice) %>% summarize(n_days=n_distinct(date)) %>% as.data.table()
swaps_10_day <- swaps %>% group_by(pool_name_nice) %>% summarize(swaps_10_day=sum(to_amount_usd)) %>% as.data.table()
swaps_10_day <- merge( swaps_10_day, n_days )
swaps_10_day[, swaps_10_day := round(swaps_10_day / n_days)]
pools.summary <- MergeDataFrames(list( daily.pool.stats[day == max_date,
list(pool_name_nice,
total_liquidity_usd = round(rune_liquidity*2*rune_price_usd))],
swaps[block_timestamp >= max(swaps$block_timestamp) - 60*60*24,
list(swaps_24h = round(sum(to_amount_usd))),
by = pool_name_nice],
swaps_10_day,
swaps[block_timestamp >= max(swaps$block_timestamp) - 60*60*24,
list(fees_24h = sum(liq_fee_asset)),
by = pool_name_nice],
daily.pool.stats %>% group_by(pool_name_nice) %>% summarize(system_rewards_usd=mean(system_rewards_usd)) %>% as.data.table(),
daily.pool.stats[!is.na(swap_fee_percent),
list(swap_fee_percent = sum(swap_volume_rune_usd *
swap_fee_percent)/sum(swap_volume_rune_usd, na.rm = T)),
by = pool_name_nice]
),
by = "pool_name_nice", all = TRUE)
RemoveNAs(pools.summary)
save(prices, pool.names, pools.summary, ten.day.swap.fee, file = "~/data_science/viz/thorchain/data.RData")
#save(, file = "/srv/shiny-server/thorswap/data.RData")
daily.pool.stats %>% group_by(pool_name_nice) %>% summarize(system_rewards_usd=sum(system_rewards_usd) / n_distinct(day)) %>% as.data.table()
pools.summary <- MergeDataFrames(list( daily.pool.stats[day == max_date,
list(pool_name_nice,
total_liquidity_usd = round(rune_liquidity*2*rune_price_usd))],
swaps[block_timestamp >= max(swaps$block_timestamp) - 60*60*24,
list(swaps_24h = round(sum(to_amount_usd))),
by = pool_name_nice],
swaps_10_day,
swaps[block_timestamp >= max(swaps$block_timestamp) - 60*60*24,
list(fees_24h = sum(liq_fee_asset)),
by = pool_name_nice],
daily.pool.stats %>% group_by(pool_name_nice) %>% summarize(system_rewards_usd=sum(system_rewards_usd) / n_distinct(day)) %>% as.data.table(),
daily.pool.stats[!is.na(swap_fee_percent),
list(swap_fee_percent = sum(swap_volume_rune_usd *
swap_fee_percent)/sum(swap_volume_rune_usd, na.rm = T)),
by = pool_name_nice]
),
by = "pool_name_nice", all = TRUE)
RemoveNAs(pools.summary)
save(prices, pool.names, pools.summary, ten.day.swap.fee, file = "~/data_science/viz/thorchain/data.RData")
#save(, file = "/srv/shiny-server/thorswap/data.RData")
pools.summary <- MergeDataFrames(list( daily.pool.stats[day == max_date,
list(pool_name_nice,
total_liquidity_usd = round(rune_liquidity*2*rune_price_usd))],
swaps[block_timestamp >= max(swaps$block_timestamp) - 60*60*24,
list(swaps_24h = round(sum(to_amount_usd))),
by = pool_name_nice],
swaps_10_day,
swaps[block_timestamp >= max(swaps$block_timestamp) - 60*60*24,
list(fees_24h = sum(liq_fee_asset)),
by = pool_name_nice],
daily.pool.stats[system_rewards_usd > 0] %>% group_by(pool_name_nice) %>% summarize(system_rewards_usd=sum(system_rewards_usd) / n_distinct(day)) %>% as.data.table(),
daily.pool.stats[!is.na(swap_fee_percent),
list(swap_fee_percent = sum(swap_volume_rune_usd *
swap_fee_percent)/sum(swap_volume_rune_usd, na.rm = T)),
by = pool_name_nice]
),
by = "pool_name_nice", all = TRUE)
RemoveNAs(pools.summary)
save(prices, pool.names, pools.summary, ten.day.swap.fee, file = "~/data_science/viz/thorchain/data.RData")
#save(, file = "/srv/shiny-server/thorswap/data.RData")
daily.pool.stats[system_rewards_usd > 0 & pool_name_nice == 'LTC [LTC]']
daily.pool.stats[system_rewards_usd > 0 & pool_name_nice == 'LTC [LTC]', list(day, system_rewards_usd)]
swaps_10_day <- swaps %>% group_by(pool_name_nice) %>% summarize(swaps_10_day=sum(to_amount_usd) * 10 / n_distinct(date)) %>% as.data.table()
pools.summary <- MergeDataFrames(list( daily.pool.stats[day == max_date,
list(pool_name_nice,
total_liquidity_usd = round(rune_liquidity*2*rune_price_usd))],
swaps[block_timestamp >= max(swaps$block_timestamp) - 60*60*24,
list(swaps_24h = round(sum(to_amount_usd))),
by = pool_name_nice],
swaps_10_day,
swaps[block_timestamp >= max(swaps$block_timestamp) - 60*60*24,
list(fees_24h = sum(liq_fee_asset)),
by = pool_name_nice],
daily.pool.stats[system_rewards_usd > 0] %>% group_by(pool_name_nice) %>% summarize(system_rewards_usd=mean(system_rewards_usd)) %>% as.data.table(),
daily.pool.stats[!is.na(swap_fee_percent),
list(swap_fee_percent = sum(swap_volume_rune_usd *
swap_fee_percent)/sum(swap_volume_rune_usd, na.rm = T)),
by = pool_name_nice]
),
by = "pool_name_nice", all = TRUE)
RemoveNAs(pools.summary)
save(prices, pool.names, pools.summary, ten.day.swap.fee, file = "~/data_science/viz/thorchain/data.RData")
#save(, file = "/srv/shiny-server/thorswap/data.RData")
swaps_10_day[ pool_name_nice == 'AVA [BNB]' ]
swaps[ pool_name_nice == 'AVA [BNB]' ]
swaps[ pool_name_nice == 'AVA [BNB]' ] %>% group_by(day) %>% summarize(volume=sum(to_amount_usd)) %>% as.data.table()
swaps[ pool_name_nice == 'AVA [BNB]' ] %>% group_by(date) %>% summarize(volume=sum(to_amount_usd)) %>% as.data.table()
swaps_10_day <- swaps %>% group_by(pool_name_nice) %>% summarize(swaps_10_day=sum(to_amount_usd) * 10 / ifelse((n_distinct(date) > 10, 10, n_distinct(date))) %>% as.data.table()
swaps_10_day <- swaps %>% group_by(pool_name_nice) %>% summarize(swaps_10_day=sum(to_amount_usd), n_days=n_distinct(date)) %>% as.data.table()
swaps_10_day[, swaps_10_day := swaps_10_day * 10 / ifelse(n_days > 10, 10, n_days) ]
swaps[ pool_name_nice == 'AVA [BNB]' ] %>% group_by(date) %>% summarize(volume=sum(to_amount_usd)) %>% as.data.table()
pools.summary <- MergeDataFrames(list( daily.pool.stats[day == max_date,
list(pool_name_nice,
total_liquidity_usd = round(rune_liquidity*2*rune_price_usd))],
swaps[block_timestamp >= max(swaps$block_timestamp) - 60*60*24,
list(swaps_24h = round(sum(to_amount_usd))),
by = pool_name_nice],
swaps_10_day[, list(pool_name_nice, swaps_10_day)],
swaps[block_timestamp >= max(swaps$block_timestamp) - 60*60*24,
list(fees_24h = sum(liq_fee_asset)),
by = pool_name_nice],
daily.pool.stats[system_rewards_usd > 0] %>% group_by(pool_name_nice) %>% summarize(system_rewards_usd=mean(system_rewards_usd)) %>% as.data.table(),
daily.pool.stats[!is.na(swap_fee_percent),
list(swap_fee_percent = sum(swap_volume_rune_usd *
swap_fee_percent)/sum(swap_volume_rune_usd, na.rm = T)),
by = pool_name_nice]
),
by = "pool_name_nice", all = TRUE)
RemoveNAs(pools.summary)
save(prices, pool.names, pools.summary, ten.day.swap.fee, file = "~/data_science/viz/thorchain/data.RData")
#save(, file = "/srv/shiny-server/thorswap/data.RData")
swaps[ pool_name_nice == 'AVA [BNB]' ] %>% group_by(date) %>% summarize(volume=sum(to_amount_usd)) %>% as.data.table()
swaps_10_day <- swaps %>% group_by(pool_name_nice) %>% summarize(swaps_10_day=sum(to_amount_usd), n_days=n_distinct(date)) %>% as.data.table()
swaps_10_day
swaps_10_day[, swaps_10_day := swaps_10_day * 10 / ifelse(n_days > 10, 10, n_days) ]
swaps_10_day
swaps[ pool_name_nice == 'LTC [LTC]' ] %>% group_by(date) %>% summarize(volume=sum(to_amount_usd)) %>% as.data.table()
daily.pool.stats[pool_name_nice == 'LTC [LTC]', list(day, system_rewards_usd)]
updated_date <- max(swaps$block_timestamp)
updated_date
save(prices, pool.names, pools.summary, ten.day.swap.fee, updated.date, file = "~/data_science/viz/thorchain/data.RData")
updated.date <- max(swaps$block_timestamp)
save(prices, pool.names, pools.summary, ten.day.swap.fee, updated.date, file = "~/data_science/viz/thorchain/data.RData")
updated.date
paste0(updated.date)
head(#212B36)
)
head(balance)
# TODO: look at stability over time
setwd("~/git/nft-deal-score/viz")
source("~/data_science/util/util_functions.R")
library(DT)
library(data.table)
library(shiny)
library(ggplot2)
library(scales)
library(shinyWidgets)
library(plotly)
library(bslib)
require(reshape2)
require(dplyr)
require(RPostgreSQL)
library(RJSONIO)
library(stringr)
library(showtext)
library(fmsb)
library(reactable)
font_add_google(name = "Roboto Condensed", family = "roboto-condensed")
font_add_google(name = "Roboto Mono", family = "roboto-mono")
showtext_auto()
# library(elementalist)
BG_COLOR = '#282923'
plotly.style <- list(
fig_bgcolor = "rgb(255, 255, 255)",
plot_bgcolor = "rgba(0, 0, 0, 0)",
paper_bgcolor = "rgba(0, 0, 0, 0)",
font = list(
color = '#919EAB', family = "Roboto Mono")
)
getTokenAddress <- function(x) {
token_address <- tryCatch(
{
strsplit( as.character(x), "\\(|\\)")[[1]][2]
},
error = function(e){
},
warning = function(w){
},
finally = {
}
)
return(token_address)
}
getTokenSymbol <- function(x) {
token_address <- tryCatch(
{
strsplit( as.character(x), "\\(|\\)")[[1]][1]
},
error = function(e){
},
warning = function(w){
},
finally = {
}
)
return(token_address)
}
printNumber <- function(x) {
return(prettyNum(x, format='d', big.mark=',', digits=5))
}
printPercent <- function(x) {
return(label_percent()(x))
}
runApp()
